CREATE table eagle_watch (
	observation_date date,
	eagles_seen integer,
	notes text
);

-- char(n): A fixed-length column where the character length is specified by n. A
--  column set at char(20) stores 20 characters per row regardless of how
--  many characters you insert. If you insert fewer than 20 characters in any
--  row, PostgreSQL pads the rest of that column with spaces. This type,
--  which is part of standard SQL, also can be specified with the longer name
--  character(n). Nowadays, char(n) is used infrequently and is mainly a
--  remnant of legacy computer systems
-- varchar(n): A variable-length column where the maximum length is specified by n. If
--  you insert fewer characters than the maximum, PostgreSQL will not store
--  extra spaces. For example, the string blue will take four spaces, whereas
--  the string 123 will take three. In large databases, this practice saves
--  considerable space. This type, included in standard SQL, also can be
--  specified using the longer name character varying(n)
-- text: A variable-length column of unlimited length. (According to the
--  PostgreSQL documentation, the longest possible character string you can
--  store is about 1 gigabyte.) The text type is not part of the SQL standard,
--  but you’ll find similar implementations in other database systems,
--  including Microsoft SQL Server and MySQL

CREATE TABLE char_data_types (
	char_column char(10),
	varchar_column varchar(10),
	text_column text
);


INSERT INTO char_data_types
VALUES 
('abc', 'abc', 'abc'),
('defghi', 'defghi', 'defghi');

COPY char_data_types TO 'E:\learning_stuff\study\database\atext.txt'
WITH (FORMAT CSV, HEADER, DELIMITER '|');


SELECT * FROM char_data_types;

-- With PostgreSQL, you have two ways to auto-increment an integer column.
--  One is the serial data type, a PostgreSQL-specific implementation of the
--  ANSI SQL standard for auto-numbered identity columns. The other is the
--  ANSI SQL standard IDENTITY keyword. Let’s start with serial.
CREATE TABLE people (
	id serial,
	person_name varchar(100)
);

SELECT * FROM people;

INSERT INTO people(person_name)
VALUES
('HUYDO'),
('NGA');

-- As of version 10, PostgreSQL includes support for IDENTITY, the standard
--  SQL implementation for auto-incrementing integers. The IDENTITY syntax is
--  more verbose, but some database users prefer it for its cross-compatibility
--  with other database systems (such as Oracle) and also because it has an
--  option to prevent users from accidentally inserting values in the auto
-- incrementing column (which serial types will permit).
-- GENERATED ALWAYS AS IDENTITY tells the database to always fill the
--  column with an auto-incremented value.
 -- user cannot insert a value into the
 -- id column without manually overriding that setting. See the OVERRIDING
 -- SYSTEM VALUE section of the PostgreSQL INSERT documentation at
 -- -- https://www.postgresql.org/docs/current/sql-insert.html for details.
 -- GENERATED BY DEFAULT AS IDENTITY tells the database to fill the column
 -- with an auto-incremented value by default if the user does not supply one.
 -- This option allows for the possibility of duplicate values, which can make
 -- use of it problematic for creating key columns.

 CREATE TABLE people2 (
	id integer GENERATED ALWAYS AS IDENTITY,
	person_name varchar(50)
 )

INSERT INTO people2(person_name)
VALUES
('HUYDO'),
('NGA');
 
SELECT * FROM people2;

-- The fixed-point type, also called the arbitrary precision type, is
--  numeric(precision,scale). You give the argument precision as the
--  maximum number of digits to the left and right of the decimal point, and the
--  argument scale as the number of digits allowable on the right of the decimal
--  point.
CREATE TABLE testing2 (
	number_test numeric(5, 3)
);

INSERT INTO testing(number_test)
VALUES (993),
(888);

SELECT * FROM testing;

INSERT INTO testing2(number_test)
VALUES (99388.8888),
(888.222);
 
-- The real type allows precision to six decimal digits, and double
--  precision to 15 decimal digits of precision

INSERT INTO number_data_types
VALUES
(.7, .7, .7),
(2.13579, 2.13579, 2.13579),
(2.1357987654, 2.1357987654, 2.1357987654);

SELECT * FROM number_data_types;

SELECT numeric_column * 10000000 AS fixed, real_column * 10000000 AS floating
FROM number_data_types
WHERE numeric_column = 0.7;


 -- Use integers when possible. Unless your data uses decimals, stick with
 -- integer types.
 -- If you’re working with decimal data and need calculations to be exact
 -- (dealing with money, for example), choose numeric or its equivalent,
 -- decimal. Float types will save space, but the inexactness of floating-point
 -- math won’t pass muster in many applications. Use them only when exactness
 -- is not as important.



 --DATE
 -- timestamp Records date and time, which are useful for a range of situations
 -- you might track: departures and arrivals of passenger flights, a schedule of
 -- Major League Baseball games, or incidents along a timeline. You will almost
 -- always want to add the keywords with time zone to ensure that the time
 -- recorded for an event includes the time zone where it occurred. Otherwise,
 -- times recorded in various places around the globe become impossible to
 -- compare. The format timestamp with time zone is part of the SQL
 -- standard; with PostgreSQL you can specify the same data type using
 -- timestamptz.
--  interval Holds a value representing a unit of time expressed in the format
--  quantity unit. It doesn’t record the start or end of a time period, only its
--  length. Examples include 12 days or 8 hours. (The PostgreSQL
--  documentation at 
-- https://www.postgresql.org/docs/current/datatype
-- datetime.html lists unit values ranging from microsecond to millennium.)
--  You’ll typically use this type for calculations or filtering on other date and
--  time columns. It’s also part of the SQL standard, although PostgreSQL
-- specific syntax offers more options
CREATE TABLE date_time_types (
	timestamp_column timestamp with time zone,
	interval_column interval
);

INSERT INTO date_time_types
VALUES
('2022-12-31 01:00 EST', '2 days'),
('2022-12-31 01:00 -8', '1 month'),
('2022-12-31 01:00 Australia/Melbourne', '1 century'),
(now(), '1 week');
-- we specify a time zone but use a different format in
--  each of the first three rows: in the first row, we use the abbreviation EST,
--  which is Eastern standard time in the United States.
-- In the second row, we set the time zone with the value -8. That represents
--  the number of hours difference, or offset, from Coordinated Universal Time
--  (UTC), the time standard for the world. The value of UTC is +/− 00:00, so-8 specifies a time zone eight hours behind UTC.
 -- For the third row, we specify the time zone using the name of an area and
 -- location: Australia/Melbourne. 


SELECT * FROM date_time_types;

INSERT INTO date_time_types VALUES (now(), '2 weeks');


 -- The interval data type is useful for easy-to-understand calculations on date
 -- and time data. For example, let’s say you have a column that holds the date a
 -- client signed a contract. Using interval data, you can add 90 days to each
 -- contract date to determine when to follow up with the client.
 
SELECT timestamp_column, interval_column, timestamp_column - interval_column AS new_date
FROM date_time_types;


{
	"bussiness_name": "Old Ebbitt Grill",
	"bussiness_type": "Restaurant",
	"employees": 300,
	"address": {
		"street": "675 15th St NW",
		"city": "Washington",
		"state": "DC"
	}
}

-- Transforming Values from One Type to
--  Another with CAST
-- Casting an integer as text is possible,
--  because the character types can include numbers. Casting text with letters of
--  the alphabet as a number is not.
SELECT timestamp_column, CAST(timestamp_column AS varchar(10))
FROM date_time_types;


SELECT numeric_column, CAST(numeric_column AS integer), CAST(numeric_column AS text)
FROM number_data_types;

SELECT CAST(char_column AS integer) FROM char_data_types;

